# О решении
Я сделал обезьяний [MVC][what-is-mvc], так тоже можно делать, это самое простое что смог придумать.

## Мое решение
На самом деле это вафленый *MVC* - нет никакой *коллекции* (она сразу передается в форму), а только *моделька* данных и *контреллер*, который умеет данные собирать.

*Модель* данных `FunctionData` ([посмотреть можно тут][functionData-class]) просто класс, который хранит данные для строки таблицы.

*Контроллер* `TableLayoutController` ([посмотреть тут][tableLayoutController-class]) просто хранит реализацию того, как надо собирать данные, и предоставляет метод, который запускает заполнение.

`ITableView` это просто интерфейс, который должна реализовывать форма, он гарантирует, что будет метод, который умеет редерить коллекцию.
*Представление* собсна описано в `MainForm.cs` в методе `AddFunctionData`. Там и происходит заполнение.

Ну и собсна все, в самой программе, позагрузке формы запускаем заполение и все.

### Почему так
Я разделил на разные файл, но вообще все это можно было сделать и в одном, просто в разных мне удобнее (и это правильнее). Наверное можно было вообще использовать один метод, который вызывался бы в `MainForm_Load` и он один бы генерировал данные, их бы заполнял итд. Не уверен, что это было бы проще для понимания, но это уж точно было бы не правильнее.

## MVC
Немного о том как я понимаю паттерн *Model-View-Controller*.

**Model** - *модель*, класс или интерфейс, который хранит нужные данные, при необходимости методы взаимодействия с данными (валидаторы, например), но в основном только хранит. Если *модель*, это описание, то во время работы прграмму существует *коллекция*, ее реализующая (один объект тоже *коллекция*, просто синглтон).

**View** - *представление* это описание того как *модель* будет выглядеть. Разметка и тому подобное.

**Controller** - *контроллер*, класс, который знает где брать данные для *модели*, умеет изменять коллекцию, содержит методы, запускающие обновление коллекции и пр.

Идеальный *MVC* я представляю так: на *представлении* описано как размещать члены *модели*, также *коллекция* (модель) биндится к представлению. Если есть элементы управления, к ним биндится *контроллер*. При обновлении коллекции *контроллером*, *представление* перестраивается, обновляется, не суть. *Представление* **не умеет** изменять *коллекцию*, только реагировать на обновление. *Контроллер* не знает ничего о том, где и как используется коллекция, под его конторолем. Подобная реализация встречается в [UWP][what-is-uwp].

### Полезные ссылки
* [MVC][what-is-mvc]
* [Описание концепта и краткий пример](https://ru.stackoverflow.com/questions/479865/%D0%9A%D0%B0%D0%BA-%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%B5%D1%81%D1%82%D0%B8-%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D1%8F-mvp-mvc-%D0%B2-%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D1%8B-winforms)
* [Пример заполнения таблицы](https://www.cyberforum.ru/windows-forms/thread1536742.html)

[functionData-class]: ./forms_CPC/Models/FunctionData.cs
[tableLayoutController-class]: ./forms_CPC/Controllers/TableLayoutController.cs

[what-is-uwp]: https://docs.microsoft.com/ru-ru/windows/uwp/get-started/universal-application-platform-guide
[what-is-mvc]: https://habr.com/ru/post/215605/